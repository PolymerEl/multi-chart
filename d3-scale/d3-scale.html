<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../helper/config-helper-mixin.html">
<link rel="import" href="../helper/logger-mixin.html">
<link rel="import" href="d3-scale-property-mixin.html">
<dom-module id="d3-scale">
  <script>
  (function() {

    /**
     * ## MultiScale
     *
     * `<d3-scale->` d3-scale component wrapper
     *     
     * @event multi-scahle-refresh
     * Fired when `scale` is mutated.
     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.MultiRegisterable
     * @appliesMixin MultiChart.mixin.ConfigHelper
     * @appliesMixin MultiChart.mixin.D3ScaleProperty
     * @appliesMixin MultiChart.mixin.Logger
     **/
    class MultiScale extends
    MultiChart.mixin.ConfigHelper(
      MultiChart.mixin.D3ScaleProperty(
        MultiChart.mixin.MultiRegisterable(
          MultiChart.mixin.Logger(
            Polymer.Element)))) {

      static get is() { return 'd3-scale'; }

      static get properties() {
        return {
          scale: {
            type: Function,
            notify: true,
            computed: '_computeScale(scaleType)'
          },

          /**
           * `_effectiveDomain` needed to reflect domain change to associated scale. 
           */
          _effectiveDomain: {
            type: Array,
            computed: '_computeEffectiveDomain(domain, _family)'
          },

          /**
           * `pretendContinuous` set true to force ordinal scale into continuous range 
           */
          pretendContinuous: {
            type: Boolean
          },

          /* 
           * `_family` inferred by scaleType. 
           * One of `continuous`, `sequential`, `quantize`, `quantile`, `threshold`, `ordinal`,            
           */
          _family: {
            type: String,
            notify: true,
            computed: '_computeFamily(scaleType)'
          }
        };
      }

      static get observers() {
        return [
          'observeConfig(padding, "padding", "scale", "refresh")',
          'observeConfig(_effectiveDomain, "domain", "scale", "refresh")',
          'observeConfig(range.*, "range", "scale", "refresh")',
          'observeConfig(domain.*, "domain", "scale", "refresh")',
          '_observeDomainMinMax(domainMin, domainMax)'
        ];
      }

      dataChanged(data) {
        if (data) {
          this.data = data;
        }

        // Note(cg): this is to prevent computing over and over
        if (this._isComputing) {
          return;
        }
        this._computeDomain();
        this._isComputing = false;
      }

      _observeDomainMinMax(min, max) {
        if (this._family === 'ordinal') {
          throw '[multi-chart] setting domain min or max is not valid for ordinal scale.';
        }
        if ((min || min === 0) || (max || max === 0)) {
          this._computeDomain(true);
        }
      }

      _computeDomain(force) {
        if (!this.data || !this.data.length) {
          return;
        }
        this._isComputing = true;
        if (this.elastic === true || !this.domain || force === true) {
          if (this._family === 'ordinal') {
            if (!this.accessor) {
              this._warn('scale is missing an accessor')
              return;
            }
            // if (this.family === 'ordinalBand') {
            const domain = this.data.map(this.accessor);

            if (this.scaleType === 'scaleBand' && this.pretendContinuous) {
              let min = -Infinity;
              domain.reduce(function(b, c) {
                var diff = c - b;
                if (diff < min) { min = diff; }
                return c;
              }, -min);
              this.domain = d3.range(domain[0], domain.pop() + 1, min);
            } else {
              this.domain = domain;
            }
          } else {
            const extent = this.accessor ?
              d3.extent(this.data, this.accessor) :
              [this.domain ? this.domain[0] : 0, this.domain ? this.domain[1] : 1];

            if (this.domainMin || this.domainMin === 0) {
              extent[0] = this.domainMin;
            }

            if (this.domainMax || this.domainMax === 0) {
              extent[1] = this.domainMax;
            }
            this.domain = extent;
          }
        }
      }

      _computeScale(type) {
        if (type) {
          if (typeof d3[type] === 'function') {
            return d3[type]();
          }
          throw (`[multi-chart] scale type is not a valid d3 scale (type is  ${type} )`);
        }
      }

      _computeEffectiveDomain(domain, _family) {
        if (domain && _family) {
          if (_family === 'continuous') {
            return d3.extent(domain);
          }
          return domain;
        }
      }

      _computeFamily(type) {
        if (!type) { return; }
        if (type === 'scaleLinear' ||
          type === 'scalePow' ||
          type === 'scaleSqrt' ||
          type === 'scaleLog' ||
          type === 'scaleIdentity' ||
          type === 'scaleTime') {
          return 'continuous';
        }
        if (type === 'scaleSequential') {
          return 'sequential';
        }
        if (type === 'scaleQuantize') {
          return 'quantize';
        }
        if (type === 'scaleQuantile') {
          return 'quantile';
        }
        if (type === 'scaleThreshold') {
          return 'threshold';
        }
        if (type === 'scaleOrdinal' ||
          type === 'scaleBand' ||
          type === 'scalePoint') {
          return 'ordinal';
        }
        throw (`[multi-chart]: scale type is not a valid d3 scale (type is ${type})`);
      }
    }

    customElements.define(MultiScale.is, MultiScale);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.MultiScale = MultiScale;

  })();
  </script>
</dom-module>