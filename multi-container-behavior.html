<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="multi-resizer-behavior.html">
<link rel="import" href="multi-svg-util-behavior.html">
<script>
(function() {
  'use strict';

  var B = Polymer.multi = Polymer.multi || {};

  var container = {

    properties: {
      // multichart: {
      //   value: true,
      //   type: Boolean,
      //   readOnly: true,
      //   reflectToAttribute: true
      // },

      // title: {
      //   type: String
      // },

      // subtitle: {
      //   type: String
      // },

      duration: {
        type: Number,
        value: 200
      },

      data: {
        type: Array,
        observer: 'renderChart'
      },

      groupName: {
        type: String
      },

      /**
       * `registeredItems` and array containing all elements that need to be refreshed when data changes 
       */
      registeredItems: {
        type: Array,
        value: function() {
          return [];
        }
      },

      attrForSerie: {
        type: String,
        value: 'index'
      },

      serieItems: {
        type: Array,
        notify: true,
        value: function() {
          return [];
        }
      }
    },

    attached: function() {
      // this.callRegistered('hostAttached');
      var boundHandler = this.__childNodesChanged.bind(this);
      this._observer = Polymer.dom(this.$.content).observeNodes(boundHandler);

      this.draw();
      this.fire('multi-attached', this.groupName);
    },

    detached: function() {
      this.fire('multi-detached', this.groupName);
    },

    listeners: {
      'multi-refresh': '__onRefresh',
      'multi-resize': '__onResize',
      // 'multi-register-item': '__onRegisterItem'
    },

    renderChart: function(data) {
      if (this.renderer) {
        this.renderer(data);
      }
    },

    draw: function() {
      var me = this;

      function draw(data) {

        if (me.chartWidth === 0) {
          return;
        }

        me.callRegistered('preDraw', data, me.duration);
        me.callRegistered('draw', data, me.duration);
        me.fire('multi-draw');

      }
      // this is the function that is called when we refresh the chart (base-behavior.renderChart(selection))
      this.renderer = function(data) {
        draw(data);
      };
    },

    callRegistered(methodName) {
      // we replace `methodName`` with `this host` as the first argument 
      // var args = [].splice.call(arguments, 0, 1, this);
      [].splice.call(arguments, 0, 1, this);
      var args = arguments;
      this.registeredItems.filter(function(el) {
        return el.isActive;
      }).forEach(function(el) {
        if (el[methodName]) {
          el[methodName].apply(el, args);

          if (methodName === 'draw' && !el.isDrawn) {
            el._setIsDrawn(true);
          }
        }
      }, this);
    },

    __onResize: function() {
      if (this.data && this.renderer) {
        this.renderer(this.data);
      }
    },

    __onRefresh: function(e, detail) {
      if (this.data && this.renderer && e.srcElement.isDrawn && this.registeredItems.indexOf(e.srcElement) > -1) {
        e.srcElement.draw(this, this.data, this.duration);
        // this.renderer(this.data);
      }
    },

    __childNodesChanged: function(nodeInfo) {
      this.__processNewNodes(nodeInfo.addedNodes);
      this.__processRemovedNodes(nodeInfo.removedNodes);
    },

    __processNewNodes: function(nodes) {
      var me = this;
      nodes.filter(function(node) {
        return node.shallRegister;
      }).forEach(function(node) {
        me.push('registeredItems', node);
        if (node.isSerie) {
          me.serieItems.push(node.getAttribute(me.attrForSerie));
        }
        if (node.afterRegister) {
          node.afterRegister(me);
        }
      });
    },

    __processRemovedNodes: function(nodes) {
      var me = this;
      nodes.filter(function(node) {
        return node.shallRegister;
      }).forEach(function(node) {
        me.splice('registeredItems', me.registeredItems.indexOf(node), 1);
        me.push('registeredItems', node);
        if (node.isSerie) {
          me.splice('serieItems', me.serieItems.indexOf(node.getAttribute(me.attrForSerie)), 1);
        }
        if (node.afterUnregister) {
          node.afterUnregister(me);
        }
      });

    },
    // __onRegisterItem: function(e, d) {
    //   if (d === true) {
    //     this.push('registeredItems', e.srcElement);
    //     if (e.srcElement.afterRegister) {
    //       e.srcElement.afterRegister(this);
    //     }
    //   }
    //   if (d === false) {
    //     this.splice('registeredItems', this.registeredItems.indexOf(e.srcElement), 1);
    //     if (e.srcElement.afterUnregister) {
    //       e.srcElement.afterUnregister(this);
    //     }
    //   }
    // }
  };

  B.container = [
    Polymer.multi.svgUtil,
    Polymer.multi.resizer,
    container
  ];

})();
</script>
