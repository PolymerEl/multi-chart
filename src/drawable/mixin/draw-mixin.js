
import { timeOut } from '@polymer/polymer/lib/utils/async.js';
import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';
import {transition} from 'd3-transition'

/**
 * ##  Draw
 * 
 * handles drawable drawing mechanism
 *
 * @memberof MultiChart.mixin   
 * @polymer
 * @mixinFunction
 */
const Draw = superClass => {

  return class extends superClass {

    static get properties() {
      
      return {

        ...super.properties,

        /* 
         * `data`  to draw the chart from
         */
        data: {
          type: Array
        },

        /* 
         * `transition` a transition composer function
         */
        transition: {
          type: Function,
          value: function() {
              // return function(transition) {
                return transition().duration(200);
              // }
          }
        },

        /* 
         * `filter` a way to filter data passed to draw method
         * 
         */
         filter : {
           type:  Function
           }

      };
    }

    /* 
     * `getDrawable` allows to specify which data to use for generating the chart. 
     * This is usefull for multi-geo where chart is generated by topojson feature and not by raw data.
     */
    get drawableData() {
      return this._shaped;
    }

    setData(data) {
       if (data) {
        // Note(cg): filter allows to dispay only a subset of the data. 
        // This is usefull for instance when we want to display multiple groups. 
        if(this.filter) {
          this.data = data.filter(this.filter);
        }
        else {this.data = data ;}
      }
    }

    // get propertiesToDraw() {
    //   return ['data'];
    // }

    // shallDraw(changedProperties) {
    //   return this.propertiesToDraw.some(k=> changedProperties.has(k))
    // }

    update(props) {
      this.log && console.info('update props', props, this)
      super.update(props);
      if(props.has('data')) {
        this._shaped = this.shape(this.data);
      }
    }

    updated(props) {
      this.log && console.info('updated props', props, this)
      super.updated(props);
      this.debounceDraw();
    }

    /* 
     * `shape` some charts are easier to draw is data is reshaped (for instance, stack chart)
     */
    shape(data) {
      return data;
    }

    debounceDraw() {
      this.log && console.info('debounce',  this)
      this._debounceDraw = Debouncer.debounce(
        this._debounceDraw, // initially undefined
        timeOut.after(10),
        () => {
          this.log && console.info('debounced',  this)
          const isDrawn = this._draw();
          this._isDrawn = !!isDrawn;
          this.dispatchEvent(new CustomEvent('multi-drawn', {detail: {}, bubbles: true, composed: true})); 
        });
    }

    /* 
     * `_draw` this is where do the work !
     */
    _draw() {
      this.log && console.error(`draw method shall be overriden in subClasses.`)
    }
    
    /* 
     * `shallTransition` called within the draw function to know if transition shall be applied 
     */
    get shallTransition() {
      // Note(cg): by default, we skip the transition for first draw.
      return this.transition && this._isDrawn === true;
    }

    dataChanged(data, transition) {
      this.log && console.info('dataChanged', this.data === data)
      this.data = data; 
      if(transition) {
        this.transition = transition;
      }
      // this._shaped = null;
      // this.render(data, transition);
    }
    /* 
     * `applyTransition`  applies a transition to chart
     */
    applyTransition(chart, tr) {
      tr = tr instanceof transition ? () => transition(tr) : tr
      return chart.transition().call(tr)
      // return chart.transition(transition(tr))
        .on('end', this.onEndTransition);
    }

    onEndTransition() {}


  };
};

/*
 * @mixinFunction
 */
export default Draw ;
