<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="multi-resizer-behavior.html">
<link rel="import" href="multi-util-behavior.html">
<script>
(function() {
  'use strict';

  var B = Polymer.multi = Polymer.multi || {};

  var base = {

    properties: {
      // multichart: {
      //   value: true,
      //   type: Boolean,
      //   readOnly: true,
      //   reflectToAttribute: true
      // },

      // title: {
      //   type: String
      // },

      // subtitle: {
      //   type: String
      // },

      duration: {
        type: Number,
        value: 200
      },

      data: {
        type: Array,
        observer: 'renderChart'
      },

      groupName: {
        type: String
      },

      /**
       * `registeredItems` and array containing all elements that need to be refreshed when data changes 
       */
      registeredItems: {
        type: Array,
        value: function() {
          return [];
        }
      }

    },

    attached: function() {
      this.fire('multi-attached', this.groupName);
      this.callRegistered('hostAttached');
      this.draw();
    },

    detached: function() {
      this.fire('multi-detached', this.groupName);
    },

    listeners: {
      'multi-resize': '__onResize',
      'multi-register-item': '__onRegisterItem'
    },

    renderChart: function(data) {
      if (this.renderer) {
        this.renderer(data);
      }
    },

    draw: function() {
      var me = this;

      function draw(data) {

        if (me.chartWidth === 0) {
          return;
        }

        me.callRegistered('preDraw', data, me.duration);
        me.callRegistered('draw', data, me.duration);
        me.fire('multi-draw');

      }
      // this is the function that is called when we refresh the chart (base-behavior.renderChart(selection))
      this.renderer = function(data) {
        draw(data);
      };
    },

    callRegistered(methodName) {
      // we replace `methodName`` with `this host` as the first argument 
      // var args = [].splice.call(arguments, 0, 1, this);
      [].splice.call(arguments, 0, 1, this);
      var args = arguments;
      this.registeredItems.forEach(function(el) {
        if (el[methodName]) {
          el[methodName].apply(el, args);
        }
      }, this);
    },

    __onResize: function() {
      if (this.data && this.renderer) {
        this.renderer(this.data);
      }
    },

    __onRegisterItem: function(e, d) {
      if (d === true) {
        this.push('registeredItems', e.srcElement);
        if (e.srcElement.afterRegister) {
          e.srcElement.afterRegister(this);
        }
      }
      if (d === false) {
        this.splice('registeredItems', this.registeredItems.indexOf(e.srcElement), 1);
        if (e.srcElement.afterUnregister) {
          e.srcElement.afterUnregister(this);
        }
      }
    }
  };

  B.base = [
    Polymer.multi.util,
    Polymer.multi.resizer,
    base
  ];

})();
</script>
