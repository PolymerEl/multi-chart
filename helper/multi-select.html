<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-selector/iron-multi-selectable.html">
<link rel="import" href="dispatch-svg-mixin.html">
<link rel="import" href="multi-registerable-mixin.html">
<link rel="import" href="track-hover-mixin.html">

<dom-module id="multi-select-style" theme-for="multi-container-svg">
  <template>
    <style>
    
    .selectable {
     cursor: pointer;
    }
    
    :host([has-selection]) .selectable {
      opacity: 0.7;
    }

    :host([has-selection]) [selected] {
      opacity: 1;
      @apply --multi-select-selected;
    }

    :host([is-hovered]) rect, :host([is-hovered]) .selectable
    {
      opacity: 0.7;
      @apply --multi-select-hovered;
    }    

    :host([is-hovered]) [hovered] rect,  :host([is-hovered]) .selectable[hovered] {
      opacity: 1;
      @apply --multi-select-selected;
    }    

    </style>
  </template>
</dom-module>

<dom-module id="multi-select">
  <script>
  (function() {

    /**
     * ## MultiSelect
     *
     * `<multi-select>` is an element for selecting ranges or chart shapes. 
     *  
     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.DispatchSVG
     * @appliesMixin MultiChart.mixin.MultiRegisterable
     * @appliesMixin MultiChart.mixin.TrackHover
     * @demo
     **/
    class MultiSelect extends
    Polymer.mixinBehaviors([Polymer.IronMultiSelectableBehavior],
      MultiChart.mixin.DispatchSVG(
        MultiChart.mixin.MultiRegisterable(
        	MultiChart.mixin.TrackHover(
          	Polymer.Element)))) {

      static get is() { return 'multi-select'; }

      static get properties() {
        return {
          /* 
           * `registerOrder` - registerable elements are sorted on the basis of this property. 
           * `multi-select` need to be last in the list of registered items, so that we attach 
           * events after all shapes are drawn.
           */
          registerOrder: {
            type: Number,
            readOnly: true,
            value: 100
          },

          /**
           * If you want to use an attribute value or property of an element for
           * `selected` instead of the index, set this to the name of the attribute
           * or property. Hyphenated values are converted to camel case when used to
           * look up the property of a selectable element. Camel cased values are
           * *not* converted to hyphenated values for attribute lookup. It's
           * recommended that you provide the hyphenated form of the name so that
           * selection works in both cases. (Use `attr-or-property-name` instead of
           * `attrOrPropertyName`.)
           */
          attrForSelected: {
            type: String,
            value: 'key'
          },


          /**
           * The attribute to set on elements when selected.
           */
          selectedAttribute: {
            type: String,
            value: 'selected'
          }
        };
      }

      dataChanged() {
        this.attachListeners();
      }

      onDrawn() {
        this.attachListeners();
        this.reSelect();
      }

      reSelect() {
        if(this.selectedItems.length) {
          this.selectedItems.forEach(item => this.select(item));
        } else if(this.selected) {
          const s = this.selected;
          this.select(null);
          this.select(s);
        }

      }

      postRemove() {
        this.detatchListeners();
      }
      
      /* 
       * `attachListeners` listen to click, mouseenter and mouseleave and 
       * fires their respective `multi` events (`multi-tap`, `multi-mouse-enter` and `multi-mouse-leave`)
       */
      attachListeners() {
        const me = this;
        const sel = d3.select(this.svgHost.shadowRoot).selectAll('.selectable')
          .on('click', function(d, i) { me.onClick(d, i, this); });

        // Note(cg): store those items into _items.  
        this._setItems(sel.nodes());

       	// attach Listeners in TrackHover
       	super.attachListeners(sel);
      }

      detatchListeners() {
        const sel = d3.select(this.svgHost.shadowRoot).selectAll('.selectable')
          .on('click', null);

       	// detatch Listeners in TrackHover
       	super.detatchListeners(sel);
      }

      getKey(d,el) {
        const keyHolder = this.attrForSelected;
        return d.data ? d.data[keyHolder] : d[keyHolder] || d.__key__ || el.getAttribute(keyHolder) || el.dataset[keyHolder] || d;
      }

      onClick(d, i, el) {
        // handle selection 
        const key = this.getKey(d, el);
        if(!key) {
          this._error(`unable to fetch key`);
        }
        if(!this.multi && key === this.selected) {
          this.select(null);
        } else {
          this.select(key);
        }
        // let the world know we have a multi-tap event.
        this.dispatchEvent(new CustomEvent('multi-tap', {detail: { data: d, index: i, element: el }, bubbles: true, composed: true})); 
      }


      get _hasSelection() {
      	return this.multi ? this.selectedValues && this.selectedValues.length : !!this.selected;
      }
      /* 
       * `_updateSelected` will set `has-selection` attribute to svgHost. 
       * This is used in multi-container-svg css rules.
       */
      _updateSelected() {
        super._updateSelected();
        if (this.svgHost) {
          d3.select(this.svgHost).attr('has-selection', this._hasSelection ? true : null);
        }
        // Note(cg): use multi select event to potentially inform multi-verse elementes that we have a selection
         this.dispatchEvent(new CustomEvent('multi-select', {detail: {
          isRange: false,
          selection: this.multi ?  this.selectedValues.slice() : this.selected
         }, bubbles: true, composed: true})); 
      }

    }


    customElements.define(MultiSelect.is, MultiSelect);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.MultiSelect = MultiSelect;

  })();
  </script>
</dom-module>