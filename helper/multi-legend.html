<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="resizable-mixin.html">
<link rel="import" href="dispatch-svg-mixin.html">
<link rel="import" href="config-helper-mixin.html">
<link rel="import" href="svg-helper-mixin.html">
<link rel="import" href="track-hover-mixin.html">
<link rel="import" href="multi-registerable-mixin.html">
<dom-module id="multi-legend-style" theme-for="multi-container-svg">
  <template>
    <style>
    #legend.legend {
      @apply --multi-legend;
    }

    #legend.legend .lecengCells {
      fill: var(--multi-legend-color, #292929);
    }

    #legend .legendTitle {
      transform: translate(0px,12px);
      @apply --multi-legend-title;
    }

    #legendRect {
      fill: var(--multi-legend-background, #efefef);
      stroke: var(--multi-legend-stroke, none);
      opacity: var(--multi-legend-opacity, 0.6);
    }
    </style>
  </template>
</dom-module>
<dom-module id="multi-legend">
  <template>
    <svg>
      <rect id="legendRect" slot-svg="slot-legend" class="legend-rect"></rect>
      <g id="legend" slot-svg="slot-legend" transform$="[[translate(x,y)]][[svgScale(scaleFactor)]]" class="legend"></g>
    </svg>
  </template>
  <script>
  (function() {

    /**
     * ## MultiLegend
     *
     * `<multi-legend>` a element for displaying chart legends
     * Relying on [d3-legend](https://d3-legend.susielu.com/), A library to make legends in svg-land easy as pie.
     *
     * ### Styling
     * `<multi-drawable-feature>` provides the following custom properties and mixins
     * for styling:
     * 
     * Custom property | Description | Default
     * ----------------|-------------|----------
     * `--multi-legend-color` | text color for legends | `#292929`
     * `--multi-legend-background` | background color for legenx box | `#efefef` 
     * `--multi-legend-stroke` | stroke color for legend box | `none` 
     * `--multi-legend-opacity` | opacity for legend box | `0.6` 
     * `--multi-legend` | Mixin applied to legend | `{}`

     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.SVGHelper
     * @appliesMixin MultiChart.mixin.MultiRegisterable
     * @appliesMixin MultiChart.mixin.DispatchSVG
     * @appliesMixin MultiChart.mixin.Resizable
     * @appliesMixin MultiChart.mixin.TrackHover
     * @appliesMixin MultiChart.mixin.Draw
     * @demo
     **/
    class MultiLegend extends
    MultiChart.mixin.ConfigHelper(
      MultiChart.mixin.SVGHelper(
        MultiChart.mixin.DispatchSVG(
          MultiChart.mixin.TrackHover(
            MultiChart.mixin.MultiRegisterable(
              MultiChart.mixin.Resizable(
                Polymer.Element)))))) {

      static get is() { return 'multi-legend'; }

      static get properties() {
        return {


          /**
           * `legendType` the type of legend (`legendColor`, `legendSize`, `legendSymbol`) 
           * for instantiating the legend ([d3-legend](http://d3-legend.susielu.com/).
           */
          legendType: {
            type: String,
            value: 'legendColor'
          },

          /* 
           * `size` of legend in the format {width, height}. This is usefull if we want to align chart margin with size of legend.
           */
          size: {
            type: Object,
            notify: true
          },

          /* 
           * `retOffset` the offset for legend rect
           */
          rectOffset: {
            type: Number,
            value: 5
          },

          legend: {
            type: Function,
            computed: '_computeLegend(legendType)'
          },

          anchor: {
            type: String,
            value: 'legend'
          },

          scaleFactor: {
            type: Number,
            value: 0.7
          },

          /**
           * `position` this position within the chart. e.g. top-right, bottom-left
           * position is recalculated on resize. 
           */
          position: {
            type: String
          },

          /**
           * `padding` the padding to be applied when calculation the position 
           */
          padding: {
            type: Number,
            value: 10
          },

          x: {
            type: Number,
            value: 0
          },

          y: {
            type: Number,
            value: 0
          },


          // API Properties
          scale: {
            type: Function
          },
          labels: {
            type: Object
          },
          cells: {
            type: Number
          },
          orient: {
            type: String
            // value: 'horizontal'
          },
          ascending: {
            type: Boolean
          },
          shape: {
            type: String
          },
          shapeWidth: {
            type: Number
          },
          shapeHeight: {
            type: Number
          },
          shapeRadius: {
            type: Number
          },
          shapePadding: {
            type: Number
          },
          useClass: {
            type: Boolean
          },
          classPrefix: {
            type: String
          },
          title: {
            type: String
          },
          labelAlign: {
            type: String
          },
          labelWrap: {
            type: Number
          },
          labelFormat: {
            type: Function
          },
          labelOffset: {
            type: Number
          },
          labelDelimiter: {
            type: String
          }
        };
      }

      static get observers() {
        return [
          'observeConfig(labels, "labels")',
          'observeConfig(scale, "scale")',
          'observeConfig(cells, "cells")',
          'observeConfig(orient, "orient")',
          'observeConfig(ascending, "ascending")',
          'observeConfig(shape, "shape")',
          'observeConfig(shapeWidth, "shapeWidth")',
          'observeConfig(shapeHeight, "shapeHeight")',
          'observeConfig(shapeRadius, "shapeRadius")',
          'observeConfig(shapePadding, "shapePadding")',
          'observeConfig(useClass, "useClass")',
          'observeConfig(classPrefix, "classPrefix")',
          'observeConfig(title, "title")',
          'observeConfig(labelAlign, "labelAlign")',
          'observeConfig(labelWrap, "labelWrap")',
          'observeConfig(labelFormat, "labelFormat")',
          'observeConfig(labelOffset, "labelOffset")',
          'observeConfig(labelDelimiter, "labelDelimiter")'
        ];
      }

      observeConfig(value, name) {
        super.observeConfig(value, name, 'legend');
        this.debounceDraw();
      }

      connectedCallback() {
        super.connectedCallback();
        Polymer.RenderStatus.afterNextRender(this, () => {
          this.addEventListener('multi-refresh', this.onRefresh);
          this.notifyResize();
        });
      }

      onRefresh(e) {
        e.stopPropagation();
        this.debounceDraw();
      }

      onResize() {
        super.onResize();
        this.debounceDraw();
      }

      debounceDraw() {
        this.debounce('multi-legend-debounce', () => {
          this.draw();
        }, 50);
      }

      draw() {
        if (!this._isDrawn) {
          d3.select(this.$.legend).attr('opacity', 0);
        }
        d3.select(this.$.legend).call(this.legend);
        setTimeout(() => { this.setPosition(); }, 10);
      }

      _computeLegend(legendType) {
        if (d3[legendType]) {
          var legend = d3[legendType]();
          this.applyConfig(legend, [
            'scale',
            'cells',
            'orient',
            'ascending',
            'shape',
            'shapeWidth',
            'shapeHeight',
            'shapeRadius',
            'shapePadding',
            'useClass',
            'classPrefix',
            'title',
            'labels',
            'labelAlign',
            'labelWrap',
            'labelFormat',
            'labelOffset',
            'labelDelimiter'
          ]);

          var me = this;
          legend.on('cellclick', function(d) { me.fire('multi-cell-click', d); });
          legend.on('cellover', d => { this.hovered = d; });
          legend.on('cellout', d => { this.hovered = null; });

          return legend;
        }
      }

      setPosition() {
        if (!this.svgHost) {
          return;
        }
        const position = this.position;
        const isRight = ~position.indexOf('right');
        const isBottom = ~position.indexOf('bottom');

        const size = this.$.legend.getBoundingClientRect();
        const chartSize = this.$.legend.ownerSVGElement.getBoundingClientRect();

        this.y = this.rectOffset + this.padding;
        this.x = this.rectOffset + this.padding;

        if (isRight) {
          // console.info('SIZE: ', size,chartWidth, padding )
          this.x = chartSize.width - size.width - this.padding + this.rectOffset;
        }

        if (isBottom) {
          this.y = chartSize.height - size.height - this.padding + this.rectOffset;
        }
        this._isDrawn = true;
        d3.select(this.$.legend).attr('opacity', 1);
        d3.select(this.$.legendRect)
          .attr('transform', `translate(${this.x - this.rectOffset}, ${this.y - this.rectOffset})`)
          .attr('width', size.width + 2 * this.rectOffset)
          .attr('height', size.height + 2 * this.rectOffset - 3);
        this.size = size;
      }
    }

    customElements.define(MultiLegend.is, MultiLegend);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.MultiLegend = MultiLegend;

  })();
  </script>
</dom-module>