<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="dispatch-svg-mixin.html">
<link rel="import" href="multi-registerable-mixin.html">
<link rel="import" href="resizable-mixin.html">
<dom-module id="multi-brush-style" theme-for="multi-container-svg">
  <template>
    <style>
    /* TODO(cg): make sure brush is styled properly;*/
    #brush rect.extent {
      fill: steelblue;
      fill-opacity: .125;
    }

    #brush .resize path {
      fill: #eee;
      stroke: #666;
    }
     
    </style>
  </template>
</dom-module>

<dom-module id="multi-brush">
  <template>
    <svg>
      <g id="brush" slot-svg="slot-brush" class="selector brush">
      </g>
    </svg>
  </template>
  </template>
  <script>
  (function() {

    /**
     * ## MultiBrush
     *
     * `<multi-brush>` implements a brush selection as in  [d3-brush](https://github.com/d3/d3-brush) 
     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @demo
     **/
    class MultiBrush extends 
      MultiChart.mixin.DispatchSVG(
        MultiChart.mixin.MultiRegisterable(
      		MultiChart.mixin.Resizable(
          	Polymer.Element))) {

      static get is() { return 'multi-brush'; }

      static get properties() {
        return {


          /**
           * Gets or sets the selected elements. This is used instead of `selected` when `multi`
           * is true.
           */
          selectedValues: {
            type: Array,
            notify: true,
            value: function() {
              return [];
            }
          },

          /**
           * Returns an array of currently selected items.
           */
          selectedItems: {
            type: Array,
            readOnly: true,
            notify: true,
            value: function() {
              return [];
            }
          },

          /**
           * `brushType` the type of selection,  either `brush`, `brushX`, `brushY`.
           * When set to `brushX` (resp. `brushY`) the `xScale` (resp. `yScale`) scale must be set. for bidirectional brush (`brush`), both scales must be given.
           */
          brushType: {
            type: String,
            value: 'brushX'
          },

          /**
           * `accessor` the accessor function to retrieve the key of selected items (it should be the xAccessor in coordinate-chart)
           */
          accessor: {
            type: Function,
            value: function() {
              return function(d) {
                return d.key;
              };
            }
          },

          xScale: {
            type: Function,
            // value: null
          },

          yScale: {
            type: Function,
            // value: null
          },


          /**
           * `brush` brushing for mouse or touch event implementation [d3-brush](https://github.com/d3/d3-brush) 
           */
          brush: {
            type: Function,
            computed: '_computeBrush(brushType, extent)'
          },

          /**
           * `extent` extent of the brush
           */
          extent: {
            type: Array,
            readOnly: true
          },

          /**
           * `isSelection` is true when a selection is being done (e.g. by brushing). The attribute is used for css rules.
           * This property is aimed at being bound to a multi-container-svg
           */
          isSelecting: {
            type: Boolean,
            value: false,
            observer: '_observeIsSelecting',
            readOnly: true
          },

          /**
           * `hasSelection`  is true when a selection exists. The attribute is used for css rules.
           * This property is aimed at being bound to a multi-container-svg
           */
          hasSelection: {
            type: Boolean,
            observer: '_observeHasSelection',
            notify: true,
            readOnly: true
          },

          isRange: {
            type: Boolean,
            notify: true,
            readOnly: true
          },
          /**
           * `xContinuous` indicate true if we have a `continuous` scale on X when the xScale is `ordinal` (e.g. a scaleBand for bar charts). If true a `xContinuousScale` is computed
           */
          xContinuous: {
            type: Boolean,
          },

          /**
           * `xContinuousScale` the continuous scale to use when selecting ranges 
           */
          xContinuousScale: {
            type: Function,
            value: function() {
              return d3.scaleLinear();
            }
          },
        };
      }

      static get observers() {
        return [
          '_observeSelectedItems(selectedItems, selectedItems.*)'
        ];
      }

      _observeSelectedItems() {
        this.debounce('multi-brush-select-debounce', () =>{
           this.dispatchEvent(new CustomEvent('multi-select', {detail: {
            isRange: this.isRange,
            selection: this.selectedItems
           }, bubbles: true, composed: true})); 
        }, 30);
      }

      onResize() {
      	super.onResize();
        this._computeExtent();
      }

      get targetElement() {
        return this.$.brush;
      }

      _observeIsSelecting(isSelecting) {
        if (this.svgHost) {
          d3.select(this.svgHost).attr('is-selecting', isSelecting ? true : null);
        }
      }

      _observeHasSelection(hasSelection) {
        if (this.svgHost) {
          d3.select(this.svgHost).attr('has-selection', hasSelection ? true : null);
        }
      }

      clearSelection() {
        // this.brush.move(null);
        if (this.brush && this.brush.move) {
          d3.select(this.targetElement).call(this.brush.move, null);
        }
        // this.splice('selectedItems', 0);
        this._setSelectedItems([]);
      }

      _computeExtent() {
        this._setExtent([
          [0, 0],
          [this.width, this.height]
        ]);
      }

      _computeBrush(brushType, extent) {
        if (brushType && extent) {
          var brush = d3[brushType]().extent(extent);
          var me = this;

          brush
            .on('start', function() {
              me.onMultiBrushStart();
            })
            .on('end', function() {
              me.onMultiBrushEnd();
            })
            .on('brush', function() {
              me.onMultiBrush();
            });

          d3.select(this.targetElement).call(brush);
          return brush;
        }
        d3.select(this.targetElement).selectAll('*').remove();
        return null;
      }

      onMultiBrush() {
        if (!d3.event.sourceEvent || this._clearing) {
          return;
        }
        const selection = d3.event.selection;

        if (!selection) {
          return this.clearSelection();
        }

        let scale = this.effectiveScale;
        // var isRange = false;

        const xScale = this.xScale;
        let sel;

        if (scale = scale.x) {
          sel = scale.y ? selection[0] : selection;
          if (scale.invert) {
            // isRange = true;
            this._setIsRange(true);
            sel = sel.map(scale.invert);
            // console.info('SEL', sel);
            if (this.selectedItems[0] !== sel[0] || this.selectedItems[1] !== sel[1]) {
              // only call the splice when needed 
              this.splice('selectedItems', 0, 2, sel[0], sel[1]);
            }
          } else {
            sel = xScale.domain().filter(function(d) {
              return sel[0] <= (d = xScale(d)) && d <= sel[1];
            });
            if (this.selectedItems.length !== sel.length || this.selectedItems[0] !== sel[0] || this.selectedItems[1] !== sel[1]) {
              // only call the splice when needed 
              this.splice.apply(this, ['selectedItems', 0, this.selectedItems.length + 1].concat(sel));
            }
          }
        }
      }

      onMultiBrushStart() {
          this._refreshContiunousScale(this.xScale);
          // this.effectiveScale = this._getEffectiveScale();
          this._setIsSelecting(true);
      }

      onMultiBrushEnd() {
        if (!d3.event.selection && !this._clearing) {
          this._clearing = true;
          this.clearSelection();
        }

        delete this._clearing;
        this._setIsSelecting(false);
      }

      _refreshContiunousScale(scale) {
        if (scale) {
          if (scale && !scale.invert && this.xContinuous) {
            var range = scale.range();
            if (scale.bandwidth) {
              // it is a scaleBand; we need to re-adjust the range taking bandWIdth and padding into account (see https://github.com/d3/d3-scale#band-scales)
              var step = scale.step();
              range = [range[0] + step / 2, range[1] - step / 2];
            }
            this.__xContinuous = this.xContinuousScale.domain(d3.extent(scale.domain())).range(range);
          } else {
            this.__xContinuous = null;
          }
        }
      }

      get effectiveScale() {
        return {
          x: (this.brushType === 'brushY' ) ? null : this.__xContinuous || this.xScale,
          y: (this.brushType === 'brushX' ) ? null : this.__yContinuous || this.yScale,
        };
      }
      
    }

    customElements.define(MultiBrush.is, MultiBrush);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.MultiBrush = MultiBrush;

  })();
  </script>
</dom-module>