<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../d3-shape/d3-shape-pie.html">
<link rel="import" href="multi-drawable.html">
<dom-module id="multi-drawable-pie">
  <template>
    <d3-shape-pie 
    	shaper="{{shaper}}" 
    	value="[[accessor]]" 
    	pad-angle="[[padAngle]]" 
    	sort="[[sort]]" 
    	sort-values="[[sortValues]]"></d3-shape-pie>
    <svg>
      <g id="drawable" slot-svg="slot-chart" class="drawable pie" transform$="[[translate(center.0, center.1)]]" />
    </svg>
  </template>
  <script>
  (function() {

    /**
     * ## MultiDrawablePie
     *
     * `<multi-drawable-pie>` draws a pie
     *
     * @memberof MultiChart
     * @element multi-drawable-chart
     * @customElement
     * @polymer
     * @demo /demo/#multi-pie-demo
     **/
    class MultiDrawablePie extends MultiChart.MultiDrawable {

      static get is() { return 'multi-drawable-pie'; }

      static get properties() {
        return {
          /* 
           * `shaper`  shaper function for generating a pie path ([pie](https://github.com/d3/d3-shape#pie))
           */
          shaper: {
            type: Function
          },
          
          /**
           * `innerRadius` the inner radius for the pie chart. It might be calculated by setting `radiusWidth` property
           */
          innerRadius: {
            value: 0
          },

          /**
           * `pieWidth` a way to indicate the width of the radius (either in % or absolute value). 
           * If set, inner radius will be inferred. 
           */
          pieWidth: {
            type: String
          },

          /**
           * `outerRadius` the outer radius for the pie. Computed as half the max size of the chart. 
           * It can be set as a Function :
           * `function(d){return 20 + Math.sqrt(d.value)}` 
           */
          outerRadius: {
            type: Function
          },

          /* 
           * `cornerRadius`corner radius for the arc as in [cornerRadius](https://github.com/d3/d3-shape#arc_cornerRadius)
           */
          cornerRadius: {
            type: Number,
            value: 0
          },

          arc: {
            type: Function,
            computed: '_computeArc(innerRadius, outerRadius, cornerRadius)'
          },

           /**
           * `sort` as in [sort](https://github.com/d3/d3-shape#pie_sort). It is null by default so as to render arcs in the provided order (same order as bound data)
           */
          sort: {
            type: Function
          },

          /**
           * `sortValue` as in [sortValues](https://github.com/d3/d3-shape#pie_sortValues). It is null by default so as to render arcs in the provided order (same order as bound data)
           */
          sortValues: {
            type: Function
          },
          
          /* 
           * `accessor` function to get value from dataset (e.g. `d => +d.value.count`)
           */
          accessor: {
            type: Function
          }

        };
      }
      static get observers() {
        return [
          '_observeForRadius(minSize)',
          '_observePieWidth(pieWidth, outerRadius)'
        ];
      }

      _observeForRadius(minSize) {
        if (typeof this.outerRadius !== 'function' && minSize) {
          this.outerRadius = minSize / 2;
        }
      }

      _observePieWidth(width, radius) {
        if (width && radius) {
          this.innerRadius = (width + '').endsWith('%') ? parseFloat(width) * radius : radius - parseFloat(width);
        }
      }

      _computeArc(innerRadius, outerRadius, cornerRadius) {
        const arc = this.arc || d3.arc();
        arc.innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);
        // Note(cg): drawable components redraw the chart on-multi-refresh.
        this.fire('multi-refresh');
        return arc;
      }

      get shapeClass() {
        return 'pie';
      }
      get shapeName() {
        return 'path';
      }

      draw(data) {

        let chart = d3.select(this.targetElement).selectAll(`${this.shapeName}.${this.shapeClass}`);

        if (this.shallTransition) {
          chart.each(function(d) {
            this._current = d;
          });
        }

        // var arcs = this.pie(data);
        const arcs = this.shaper(data); //this.$.shaper.shapedData;
        const arc = this.arc;
        const colorScale = this.colorScale;

        chart = chart.data(arcs);

        chart.exit().remove();

        chart = chart.enter().append(this.shapeName)
          .attr('class',`${this.shapeClass} selectable shape`)
          .merge(chart);

        if (this.shallTransition) {
          //as in https://bl.ocks.org/mbostock/5100636
          function arcTween(a) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t) {
              return arc(i(t));
            };
          }

          chart = this.applyTransition(chart, this.transition);

          chart
            .attrTween('d', arcTween);

        } else {
          chart
            .attr('d', arc);
        }

        chart.attr('key', function(d) {
            return d.data.key;
          })
          .attr('fill', function(d) {
            return colorScale(d.data.key);
          });

        return chart;  
      }
    }

    customElements.define(MultiDrawablePie.is, MultiDrawablePie);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

   /* 
    * @namespace MultiChart
    */
    window.MultiChart.MultiDrawablePie = MultiDrawablePie;

  })();
  </script>
</dom-module>