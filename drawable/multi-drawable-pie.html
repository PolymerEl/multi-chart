<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../d3-shape/d3-shape-pie.html">
<link rel="import" href="../d3-shape/property/d3-shape-stack-mixin.html">
<link rel="import" href="../helper/multi-accessor.html">
<link rel="import" href="multi-drawable.html">
<dom-module id="multi-drawable-pie">
  <template>
     <multi-accessor accessor="{{value}}" path="[[valuePath]]" ></multi-accessor>
    <d3-shape-pie 
      shaper="{{shaper}}" 
      value="[[value]]" 
      pad-angle="[[padAngle]]" 
      sort="[[sort]]" 
      sort-values="[[sortValues]]"></d3-shape-pie>
    <svg>
      <g id="drawable" slot-svg="slot-chart" class="drawable pie" transform$="[[translate(center.0, center.1)]]" />
    </svg>
  </template>
  <script>
  (function() {

    /**
     * ## MultiDrawablePie
     *
     * `<multi-drawable-pie>` draws a pie
     *
     * @memberof MultiChart
     * @element multi-drawable-chart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.D3PieProperty
     * @demo index.html#multi-pie-demo
     **/
    class MultiDrawablePie extends 
      MultiChart.mixin.D3PieProperty(
        MultiChart.MultiDrawable) {

      static get is() { return 'multi-drawable-pie'; }

      static get properties() {
        return {
          /* 
           * `shaper`  shaper function for generating a pie path ([pie](https://github.com/d3/d3-shape#pie))
           */
          shaper: {
            type: Function
          },
          
          /**
           * `innerRadius` the inner radius for the pie chart. It might be calculated by setting `radiusWidth` property
           */
          innerRadius: {
            value: 0
          },

          /**
           * `pieWidth` a way to indicate the width of the radius (either in % or absolute value). 
           * If set, inner radius will be inferred. 
           */
          pieWidth: {
            type: String
          },

          /**
           * `outerRadius` the outer radius for the pie. Computed as half the max size of the chart. 
           * It can be set as a Function :
           * `function(d){return 20 + Math.sqrt(d.value)}` 
           */
          outerRadius: {
            type: Function
          },

          /* 
           * `cornerRadius`corner radius for the arc as in [cornerRadius](https://github.com/d3/d3-shape#arc_cornerRadius)
           */
          cornerRadius: {
            type: Number,
            value: 0
          },

          arc: {
            type: Function,
            computed: '_computeArc(innerRadius, outerRadius, cornerRadius)'
          }

        };
      }
      static get observers() {
        return [
          '_observeForRadius(minSize)',
          '_observePieWidth(pieWidth, outerRadius)'
        ];
      }

      _observeForRadius(minSize) {
        if (typeof this.outerRadius !== 'function' && minSize) {
          this.outerRadius = minSize / 2;
        }
      }

      _observePieWidth(width, radius) {
        if (width && radius) {
          this.innerRadius = (width + '').endsWith('%') ?  radius * (1 - parseFloat(width)/100) : radius - parseFloat(width);
        }
      }

      _computeArc(innerRadius, outerRadius, cornerRadius) {
        const arc = this.arc || d3.arc();
        arc.innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(cornerRadius);
        // Note(cg): drawable components redraw the chart on-multi-refresh.
        this.fire('multi-refresh');
        return arc;
      }

      get shapeClass() {
        return 'pie';
      }
      get shapeName() {
        return 'path';
      }

      draw(data) {
        if(!this.width || !this.height) {
          return;
        }

        let chart = d3.select(this.targetElement).selectAll(`${this.shapeName}.${this.shapeClass}`);

        if (this.shallTransition) {
          chart.each(function(d) {
            this._current = d;
          });
        }

        // var arcs = this.pie(data);
        const arcs = this.shaper(data); //this.$.shaper.shapedData;
        const arc = this.arc;
        const colorScale = this.colorScale;

        chart = chart.data(arcs);

        chart.exit().remove();

        chart = chart.enter().append(this.shapeName)
          .attr('class',`${this.shapeClass} selectable shape`)
          .merge(chart);

        if (this.shallTransition) {
          //as in https://bl.ocks.org/mbostock/5100636
          function arcTween(a) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t) {
              return arc(i(t));
            };
          }

          chart = this.applyTransition(chart, this.transition);

          chart
            .attrTween('d', arcTween);

        } else {
          chart
            .attr('d', arc);
        }

        chart.attr('key', function(d) {
            return d.data.key;
          })
          .attr('fill', function(d) {
            return colorScale(d.data.key);
          });

        return chart;  
      }
    }

    customElements.define(MultiDrawablePie.is, MultiDrawablePie);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

   /* 
    * @namespace MultiChart
    */
    window.MultiChart.MultiDrawablePie = MultiDrawablePie;

  })();
  </script>
</dom-module>