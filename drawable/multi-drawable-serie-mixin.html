<script>
(function() {

  /**
   * ##  MultiDrawableSerie
   * 
   * a Mixin to implement generic draw function for seriest
   * 
   * @memberof MultiChart.mixin
   * @polymer
   * @mixinFunction
   */
  const MultiDrawableSerie = superClass => {

    return class extends superClass {

      static get properties() {
        return {
          /* 
           * `shaper`  shaper function for generating a line path ([pie](https://github.com/d3/d3-shape#lines)
           */
          shaper: {
            type: Function
          },

          /* 
           * `xAccessor` for serie data. 
           * As data has been reshaped in `multi-data-mixin` as {key: key, value: value}, 
           * `_xAccessor` sould be d => d.key
           */
          xAccessor: {
            type: Function,
            value: function() {
              // return this.indexAccessor;
              return this.keyAccessor;
            }
          },

          yAccessor: {
            type: Function,
            value: function() {
              // return this.identity;
              return this.valueAccessor;
            }
          },

          /* 
           * `selectSerie` if true, will set the `selectable` attribute at serie level. Default (falsy) will 
           * add `selectable` attribute to each individual shape (rect in car chart, circle in bubble chart)
           */
          selectSerie: {
            type: Boolean
          }

        };
      }

      get shapeClass() {
        this._warn('shapeClass need to be overriden in subClass.');
        return 'serie';
      }

      get shapeName() {
        return 'path';
      }

      drawSerieElement(chart, data) {
        this._warn('drawing serie element shall be implemented in subclass');
        return chart;
      }

      /* 
       * `drawSerieGroup` builds one level of data  binding -> remove superfluous -> append new -> merge -> return chart
       * We can hence call this function for first grouping all keys and then build individual shapes (see multi-drawable-bubble)
       */
      drawSerieGroup(data, shapeName, shapeClass, chart, transition) {
        const isTransition = chart && chart instanceof d3.transition;
        const cls = chart ? 'shape' : 'shape-group';
        chart = chart ?
          isTransition ?
          chart.selection().selectAll(`${shapeName}.${shapeClass}`).data(d => d.data || d) :
          chart.selectAll(`${shapeName}.${shapeClass}`).data(d => d.data || d) :
          d3.select(this.targetElement).selectAll(`${shapeName}.${shapeClass}`).data(data);

        chart.exit().remove();

        chart = chart.enter().append(shapeName)
          .attr('class', `${shapeClass} ${cls}`)
          .merge(chart);

        if (this.shallTransition && transition) {
          chart = this.applyTransition(chart, transition);
        }
        return chart;

      }

      /* 
       * `draw` serie data, which are in the form of [{key, label, data: [dataValues]}]
       */
      draw(data) {
        if(!this.width || !this.height) {
          return;
        }

        let chart = this.drawSerieGroup(data, this.shapeName, this.shapeClass, null, this.transition);

        // Note(cg): individual serie members (e.g. draw individual line or bar) are handled by subclasses .
        return this.drawSerieElement(chart, data);

      }
    };
  };

  if (!window.MultiChart) {
    window.MultiChart = {};
  }

  /* 
   * @namespace MultiChart.mixin
   */
  window.MultiChart.mixin = window.MultiChart.mixin || {};
  /* 
   * @mixinFunction
   */
  window.MultiChart.mixin.MultiDrawableSerie = MultiDrawableSerie;

})();
</script>