<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="multi-drawable.html">
<link rel="import" href="multi-drawable-serie-mixin.html">

<dom-module id="multi-drawable-bubble-style" theme-for="multi-container-svg">
  <template>
    <style>
      #drawable.bubble {
        @apply --drawable-bubble;
      }

      #drawable.bubble .shape {
        fill: var(--drawable-bubble-fill);
        stroke: var(--drawable-bubble-stroke);
      }
      
    </style>
  </template>
</dom-module>

<dom-module id="multi-drawable-bubble">
  <template>
    <svg>
      <g id="drawable" slot-svg="slot-chart" class="drawable bubble"></g>
    </svg>
  </template>
  <script>
  (function() {

    /**
     * ## MultiDrawableBubble
     *
     * `<multi-drawable-bubble>` draw bubbles from serie data
     *     
     * ### Styling
     * 
     * The following custom properties and mixins are available for styling:
     * 
     * Custom property | Description | Default
     * ----------------|-------------|----------
     * `--drawable-bubble` | mixin applied to drawable | `{}`
     * `--drawable-bubble-fill` | fill color applied to bubble | `none`
     * `--drawable-bubble-strole` | stroke color applied to bubble | `none`
     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.MultiDrawableSerie
     * @appliesMixin MultiChart.mixin.D3ShapeCoordinate
     * @demo
     **/
    class MultiDrawableBubble extends
    	MultiChart.mixin.MultiDrawableSerie(
    		MultiChart.mixin.D3ShapeCoordinate(
    			MultiChart.MultiDrawable)) {

      static get is() { return 'multi-drawable-bubble'; }

      static get properties() {
        return {

        	/* 
        	 * `z` calculating radius for all data point radius = z(d)
        	 */
          z: {
            type: Function,
            readOnly: true
          },

           /* 
           * `zAccessor`  the accessor function for z data (circle radius)
           */
          zAccessor: {
            type: Function,
            value: function() {
              return this.valueAccessor;
            }
          },

          /* 
           * `zScale` scale function for z domain (circle radius)
           */
          zScale: {
            type: Function
          }

        };
      }

      static get observers() {
        return [
           '_observeScaleAccessor(zScale, zAccessor, "Z")',
        ];
      }
      get shapeClass() {
        return 'bubble';
      }

      get shapeName() {
        return 'g';
      }

      drawSerieElement(chart, data) {
      	chart
      		.attr('fill', d => this.colorScale(d.key))
          .attr('class', `${this.shapeClass} selectable`)
          .attr('key', d => d.key);

        chart = this.drawSerieGroup(data, 'circle', this.shapeClass, chart, this.transition);

        return chart.attr('cx', this.x || 0)
          .attr('cy', this.y || 0)
          .attr('r', this.z || 0)
          .attr('index', (d,i) => i);
      }

    }

    customElements.define(MultiDrawableBubble.is, MultiDrawableBubble);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.MultiDrawableBubble = MultiDrawableBubble;

  })();
  </script>
</dom-module>