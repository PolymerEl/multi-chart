<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../helper/svg-helper-mixin.html">
<link rel="import" href="../helper/accessor-mixin.html">
<link rel="import" href="../helper/multi-register-mixin.html">
<link rel="import" href="../helper/multi-data-mixin.html">
<link rel="import" href="../d3-zoom/zoomable-mixin.html">
<link rel="import" href="../multi-chart-base.html">
<dom-module id="multi-container-svg">
  <template>
    <!-- <style include="multi-container"></style> -->
    <style>
    :host {
      display: block;
      @apply --layout-center-center;
      flex: 1;
      height: 100%;
    }

    ::slotted([slot=header]),
    ::slotted([slot=footer]) {
      margin: 0;
    }

    #observedNode {
      display: none;
    }

    #svg {
      /* need width here, otherwise the size of this svg is not properly calculated on resize*/
      width: 100%;
      height: 100%;
      @apply --multi-container-svg;
    }

    #background {
      fill: var(--multi-chart-background-color, var(--light-theme-background-color));
      @apply --multi-chart-background;
    }

    #slot-chart-content {
      @apply --multi-chart-content;
    }

    .drawable {
      fill: none;
    }

    slot[name="svg"] {
      display: none;
    }

    /*.highlight .highlighted {
      fill: green;
    }*/
    </style>
    <slot name="header"></slot>
    <div id="observedNode">
      <slot></slot>
    </div>

    <svg id="svg">
      <g transform$="[[translate(margin.left, margin.top)]]">
        <g id="slot-background">
        </g>
        <g id="slot-chart-content">
          <g id="slot-zoom">
            <g id="slot-chart" class="chart">
            </g>
            <g id="slot-brush"></g>
          </g>
          <g id="slot-axis"></g>
        </g>
      </g>
      <g id="slot-legend"></g>
    </svg>
    <slot name="footer"></slot>
    <slot name="svg"></slot>

    <!-- we include patterns in the template so as to be able to use them in css (mask: url(#mask-stripe-thick)) -->
    <svg style="width:3000px; height: 3000px; position:absolute; top:-100000px;">
      <defs>
        <pattern id="pattern-stripe" width="5" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate(-45)">
          <rect width="0.5" height="4" transform="translate(0,0)" fill="white"></rect>
        </pattern>
        <pattern id="pattern-stripe-thick" width="5" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate(-45)">
          <rect width="2.5" height="4" transform="translate(0,0)" fill="white"></rect>
        </pattern>
        <pattern id="pattern-stripe-light" width="5" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate(-45)">
          <rect width="4" height="4" transform="translate(0,0)" fill="white"></rect>
        </pattern>
        <pattern id="pattern-stripe-hor" width="5" height="4" patternUnits="userSpaceOnUse">
          <rect width="0.5" height="4" transform="translate(0,0)" fill="white"></rect>
        </pattern>
        <pattern id="pattern-stripe-inverse" width="5" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
          <rect width="0.5" height="4" transform="translate(0,0)" fill="white"></rect>
        </pattern>
        <pattern id="pattern-stripe-thick-inverse" width="5" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
          <rect width="2.5" height="4" transform="translate(0,0)" fill="white"></rect>
        </pattern>
        <mask id="mask-stripe">
          <rect x="-500" y="-500" width="1000" height="1000" fill="url(#pattern-stripe)" />
        </mask>
        <mask id="mask-stripe-thick">
          <rect x="-500" y="-500" width="1000" height="1000" fill="url(#pattern-stripe-thick)" />
        </mask>
          <mask id="mask-stripe-light">
          <rect x="-500" y="-500" width="1000" height="1000" fill="url(#pattern-stripe-light)" />
        </mask>
        <mask id="mask-stripe-inverse">
          <rect x="-500" y="-500" width="1000" height="1000" fill="url(#pattern-stripe-inverse)" />
        </mask>
        <mask id="mask-stripe-thick-inverse">
          <rect x="-500" y="-500" width="1000" height="1000" fill="url(#pattern-stripe-thick-inverse)" />
        </mask>
        <mask id="mask-stripe-hor">
          <rect x="-500" y="-500" width="1000" height="1000" fill="url(#pattern-stripe-hor)" />
        </mask>
      </defs>
    </svg>
  </template>
  <script>
  (function() {
    /**
     * # MultiContainerSVG
     * 
     * `<multi-chart-base>` is a base element for buiding charts 
     *
     *
     * ### Events
     * Fired when `multi-container-svg` is attached .
     *
     * @event multi-verse-added
     * @param {string} the name of the current group.
     *
     * Fired when `multi-container-svg` is removed .
     *
     * @event multi-container-removed
     * @param {string} the name of the current group.
     *
     *
     * @memberof MultiChart
     * @appliesMixin  Vaadin.ThemableMixin    
     * @appliesMixin  MultiChart.mixin.MultiRegister    
     * @appliesMixin  MultiChart.mixin.SVGHelper   
     * @appliesMixin MultiChart.mixin.Accessor
     * @appliesMixin  MultiChart.mixin.Zoomable
     * @customElement
     * @polymer
     **/
    class MultiContainerSVG
    extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior],
      Vaadin.ThemableMixin(
        MultiChart.mixin.SVGHelper(
          MultiChart.mixin.Accessor(
            MultiChart.mixin.MultiRegister(
              MultiChart.mixin.Zoomable(
                MultiChart.MultiChartBase)))))) {

      static get is() { return 'multi-container-svg'; }

      static get properties() {
        return {

          /* 
           * `margin` applied to svg container (not css margin, wich can also be applied as per normal css rules)
           */
          margin: {
            type: Object,
            value: {
              top: 10,
              right: 5,
              bottom: 10,
              left: 5
            }
          },

          /* 
           * `width`  of the chart area. Equals actual width of component - margins
           */
          width: {
            type: Number,
            readOnly: true
          },

          /* 
           * `height`  of the chart area. Equals actual height of component - margins
           */
          height: {
            type: Number,
            readOnly: true
          },

          /**
           * `groupName` the name of the group (used when to registering this element under a multi-verse)
           */
          groupName: {
            type: String
          },



        };
      }

      static get observers() {
        return [
          '_observeMargin(margin.*)'
        ];
      }

      connectedCallback() {
        super.connectedCallback();
        // Note(cg): we fire a special event so that multi-verse are aware of chart container being added
        // TODO(cg): replace multi-attached -> multi-verse-added
        Polymer.RenderStatus.afterNextRender(this, () => {
          this.dispatchEvent(new CustomEvent('multi-verse-added', { detail: this.groupName, bubbles: true, composed: true }));
          this.addEventListener('iron-resize', this.onResize);
          this.notifyResize();
          this.assignSlottedSVG();
        });
      }

      assignSlottedSVG() {
        const nodes = [];
        const treeWalker = (root) => {
          return document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, { acceptNode: function(node) {return NodeFilter.FILTER_ACCEPT;}}, false);
        };

        const assignedNodes = (node) => {
          let n = node;
          while(n.assignedNodes && n.assignedNodes()[0] ) {
            n = n.assignedNodes()[0];
          }
          return n;
        };

        const loop = (node) => {
          const walker = treeWalker(node);
          while (walker.nextNode()) {
            const currentNode = walker.currentNode;
            if (currentNode.getAttribute('slot-svg')) {
              // Note(cg): we push slot-svg here.
              nodes.push(currentNode);
            }
            // Note(cg): slotted assigned elements are not catched by try treewalker.
            if(currentNode.localName === 'slot') {
              loop(assignedNodes(currentNode));
            }
          }
        };
        loop(this);

        nodes.forEach(node => {
           const target = node.getAttribute('slot-svg');
            if (this.$[target]) {
              // this._hostedNodes[target] = node;
              return this.$[target].appendChild(node);
            }
            this._warn(`cannot dispatch node ${target}`);
        });
        // console.info('NODES', nodes);
      }

      _observeMargin() {
        this.notifyResize();
      }


      disconnectedCallback() {
        super.disconnectedCallback();
        // TODO(cg): replace multi-removed -> multi-verse-remover
        // XXX(cg): this event will never be caught! unregister from host instead like for drawablse
        this.dispatchEvent(new CustomEvent('multi-verse-removed', { detail: this.groupName, bubbles: true, composed: true }));
      }

      onResize() {
        // Note(cg): if width or height is 0 (as it is the case when char is hiddem -> do nothing).
        if (this.$.svg.width.baseVal.value && this.$.svg.height.baseVal.value) {
          // Note(cg): as we cannot user offsetWidth and offsetHeight for svg, we take the value of $0.$.svg.height.baseVal.
          this._setWidth(Math.floor(this.$.svg.width.baseVal.value - this.margin.left - this.margin.right));
          this._setHeight(Math.floor(this.$.svg.height.baseVal.value - this.margin.bottom - this.margin.top));
          this._canCallResize = 0;
          super.onResize();
          return;
        }
        // Note(cg): onResize is called too fast sometimes (this.$.svg is not yet resized) and we need to re-call it slightly later 
        // This happens for instance when we have a chart within iron-pages
        if(!this._canCallResize) {
          this._canCallResize = 1;
          setTimeout(() =>{
            this.onResize(); 
            this._canCallResize = 0;
          }, 10);
        }
      }


      _onMultiSerieRegister(e) {
        e.stopPropagation();
        this._registerItem('series', e.composedPath()[0]);
      }

    }

    customElements.define(MultiContainerSVG.is, MultiContainerSVG);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    window.MultiChart.MultiContainerSVG = MultiContainerSVG;

  })();
  </script>
</dom-module>