<script>
(function() {

  /**
   * ##  ContainerAxisProperty
   * 
   * Properties for container axis.
   * 
   * @memberof MultiChart.mixin
   * @polymer
   * @mixinFunction
   */
  const ContainerAxisProperty = superClass => {

    return class extends superClass {

      static get properties() {
        return {
          /* 
           * `data` to display the chart
           */
          data: {
            type: Array
          },

          /* 
           * `margin` applied to svg container (not css margin, wich can also be applied as per normal css rules)
           * By default margins are slightly bigger than for simple `multi-container-svg`
           */
          margin: {
            type: Object,
            value: {
              top: 20,
              right: 20,
              bottom: 20,
              left: 30
            }
          },

          /* 
           * `scales` key-value [scale](https://github.com/d3/d3-scale) for the active axis. `bottom` and `left` scales are always calculated. `right` and `top` scales are set only when 
           * right and top axis is drawn. 
           */
          scales: {
            type: Object,
            notify: true,
            value: function() {
              return {};
            }
          },

          /* 
           * `domains` key-value [domain](https://github.com/d3/d3-scale#domain) for active axis. By default, `{bottom: bottomDomain, left:leftDomain}`
           */
          domains: {
            type: Object,
            notify: true,
            value: function() {
              return {};
            }
          },

          /* 
           * `ranges` key-value [range](https://github.com/d3/d3-scale#range) for active axis.
           */
          ranges: {
            type: Object,
            notify: true,
            value: function() {
              return {};
            }
          },
          /* 
           * `accessors` key-value accessor functions for active axis.
           */
          accessors: {
            type: Object,
            notify: true,
            value: function() {
              return {};
            }
          },

          /* 
           * `topAxis` true to display top axis
           */
          topAxis: {
            type: Boolean,
            value: false
          },

          /* 
           * `rightAxis` true to display right axis
           */
          rightAxis: {
            type: Boolean,
            value: false
          },
          /* 
           * `bottomAxis` true to display bottom axis
           */
          bottomAxis: {
            type: Boolean,
            value: false
          },

          /* 
           * `leftAxis` true to display left axis
           */
          leftAxis: {
            type: Boolean,
            value: false
          },


          leftTextAngle: {
            type: Number,
            value: -90
          },

          leftYText: {
            type: Number,
            value: 6
          },

          leftDy: {
            type: String,
            value: '0.6em'
          },

          bottomDy: {
            type: String,
            value: '-0.6em'
          },

          /* 
           * `serieValueDomain` value domain for each serie groupName, calculated in `multi-register-mixin`
           * if no groupName is given a default `default` name is given. Hence this field results to serieValueDomain = {default: [min, max]}
           */
          serieValueDomain: {
            type: Object,
            notify: true
          },

          /* 
           * `serieOrdinalDomain` ordinal domain for series
           */
          serieOrdinalDomain: {
            type: Object,
            notify: true
          },

          /* 
           * `serieDomainMapping` a mapping object that will make sure that scale domains are properly set when we use data series. 
           * the default mapping will use value domain for left axis and ordinal domain for bottom axis
           */
          serieDomainMapping: {
            type: Object,
            value: {
              'bottom': 'serieOrdinalDomain.default',
              'left': 'serieValueDomain.default'
            }
          },

          /* 
           * `elastic` a mapping object for storing elastic axis. 
           */
           // elastic : {
           //   type: Object,
           //   notify: true,
           //   value: function() {
           //      return {};
           //    }
           //  },

          /* 
           * `ordinalDomainAccessor` a mapper for serie ordinal valued. 
           */
          ordinalDomainAccessor: {
            type: Function
          },

          /* 
           * `dataStack` when true, will flatten data so taht it is in the right format to be parsed by d3.stack()
           * this is mainly the case for bar/stack chart
           */
          dataStack: {
            type: Boolean
          },

          topAccessorPath: String,
          rightAccessorPath: String,
          bottomAccessorPath: String,
          leftAccessorPath: String
        };
      }

      static get observers() {
        return [
          '_observeSerieDomain(serieDomainMapping, serieOrdinalDomain, serieValueDomain)'
        ];
      }

      ready() {
        super.ready();
        Polymer.RenderStatus.afterNextRender(this, () => {
          this.addEventListener('multi-set-value-domain', this._onSetValueDomain);
        });
      }

      /* 
       * `_onSetValueDomain` some charts will reset domain according to reshaped values (e.g. stack chart)
       * This provides a way to listing to those changes. 
       */
      _onSetValueDomain(e) {
        e.stopPropagation();
        const d = e.detail;
        this.serieValueDomain = Object.assign({}, this.serieValueDomain || {}, {
          [`${d.serieName || 'default'}`]: d.domain });
      }

      _observeSerieDomain(mapping) {
        // TODO(cg): check whether we have elastic axis.
        if (mapping) {
          Object.keys(mapping).forEach(k => {
            if (['left', 'bottom', 'right', 'top'].indexOf(k) < 0) {
              throw `[multi-chart] serieDomainMapping has an invalid key (${k}). Expected: one of this.domain ? this.domain[0] : 0,`;
            }
            const domain = this.get(mapping[k]);
            if (domain) {
              if (this[`${k}DomainMin`] || this[`${k}DomainMin`] === 0) {
                domain[0] = this[`${k}DomainMin`];
              }
              if (this[`${k}DomainMax`] || this[`${k}DomainMax`] === 0) {
                domain[1] = this[`${k}DomainMax`];
              }
              const elastic = this[`${k}Elastic`];
              if(elastic || !this.domains[k]) {
                this.set(`domains.${k}`, domain);
              } else  {
                this.notifyPath(`domains.${k}.0`, null);
              }
            }
          });
        }
      }
    };
  };

  if (!window.MultiChart) {
    window.MultiChart = {};
  }

  /* 
   * @namespace MultiChart.mixin
   */
  window.MultiChart.mixin = window.MultiChart.mixin || {};
  /* 
   * @mixinFunction
   */
  window.MultiChart.mixin.ContainerAxisProperty = ContainerAxisProperty;

})();

</script>
