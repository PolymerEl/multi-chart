<script>
(function() {

  /**
   * ## MultiRegister
   * 
   * The responsibility of this mixin is to observe nodes added to `#obseveNodes`. 
   * It adds elements fireing a`multi-register to `_registeredItems` and elements 
   * fireing `multi-serie-register` to `series`.
   * 
   *
   * @memberof MultiChart.mixin
   * @polymer
   * @mixinFunction
   */
  const MultiRegister = Polymer.dedupingMixin(superClass => {

    /*
     * @polymer
     * @mixinClass
     */
    class Register extends superClass {

      static get properties() {
        return {
          /* 
           * `_registeredItems`  the list of registered items (registerable items)
           */
          _registeredItems: {
            type: Array,
            value: function() {
              return [];
            }
          },

          /* 
           * `series` the list of data serie registered for this container. 
           * We can eiher pass a serie array like [{key: 'apple', label:'apple'}, accessor: d => +d.value.apple}, {key: 'orange', label:'orange'}, accessor: d => +d.value.orange}], 
           *  or use `<multi-serie>` component to register series via markup
           *
           */
          series: {
            type: Array,
            notify: true,
            value: function() {
              return [];
            }
          },

          /* 
           * `data` to display the chart
           */
          data: {
            type: Array
          },

          /* 
           * `transition` to apply while drawing
           */
          transition: {
            type: Function
          },

          /* 
           * `serieValueDomain` value domain for each serie groupName. 
           * if no groupName is given a default `default` name is given. Hence this field results to serieValueDomain = {default: [min, max]}
           */
          serieValueDomain: {
            type: Object,
            notify: true
          },

          /* 
           * `serieOrdinalDomain` ordinal domain for series
           */
          serieOrdinalDomain: {
            type: Object,
            notify: true
          },

          /* 
           * `ordinalDomainMapper` a mapper for serie ordinal valued. By default, identity function.
           */
          ordinalDomainMapper: {
            type: Function
          },

          /* 
           * `_multiData` reshaped data to use internally within MultiChart. 
           * 
           */
          _multiData: {
            type: Array
          }

        };
      }

      static get observers() {
        return [
          '_observeDataGenerators(data, data.splices, series.splices)',
          '_callDataChanged(_multiData)'
        ];
      }

      ready() {
        super.ready();
        this.addEventListener('multi-register', this._onMultiRegister);
        this.addEventListener('multi-serie-register', this._onMultiSerieRegister);
        setTimeout(() => { this.addEventListener('multi-refresh', this._onRefresh); }, 500);
      }

      _observeDataGenerators() {
        this.debounce('multi-register-data-generator-debounce', () => {
          if (Array.isArray(this.data) && this.data.length) {
            if (this.series && this.series.length) {
              /* Note(cg): we transform serie data only if all serie item have an accessor function.  
               * The reason for this is that some shape type - d3.stack - expect data not to be grouped by series,
               * While other shape type - d3.bar, d3-line - work best with data grouped by serie. 
               */
              const hasAccessors = this.series.every(item => item.accessor);

              if (hasAccessors) {
                const valueDomain = {};
                const ordinalDomain = {};
                const _multiData = this.series.map(item => {
                  const data = this.data.map(item.accessor);
                  const groupName = item.groupName || 'default';
                  if (!valueDomain[groupName]) { valueDomain[groupName] = [Infinity, -Infinity]; }
                  if (!ordinalDomain[groupName]) { ordinalDomain[groupName] =  this.getOrdinalDomain(this.data, this.ordinalDomainMapper);}
                  const extent = d3.extent(data);
                  if (extent[0] < valueDomain[groupName][0]) { valueDomain[groupName][0] = extent[0]; }
                  if (extent[1] > valueDomain[groupName][1]) { valueDomain[groupName][1] = extent[1]; }
                  return { key: item.key, label: item.label || item.key, groupName: groupName, data: data };
                });
                this.serieOrdinalDomain = ordinalDomain;
                this.serieValueDomain = valueDomain;
                // Note(cg): we set multidata after domains are computed
                this._multiData = _multiData;
              } else {
                const ordinalDomain = {};
                this.series.forEach(item => {
                  const groupName = item.groupName || 'default';
                  if (!ordinalDomain[groupName]) { ordinalDomain[groupName] = this.getOrdinalDomain(this.data, this.ordinalDomainMapper); }
                });
                this.serieOrdinalDomain = ordinalDomain;
                this._multiData = this.data;
              }
              return;
            }
            this._multiData = this.data;
          }
          else {
            this._multiData = this.data;
          }

        }, 30);
      }

      getOrdinalDomain(data, mapper) {
        if(mapper) {
          const map = [];
          data.forEach((d,i) => {
            d.__key__ = mapper(d,i);
            map.push(d.__key__);
          } );
          return map;
        }
        return d3.range(data.length);
      }

      _callDataChanged(splices) {
        if (this.shallNotify(this._multiData)) {
          this.callRegistered('dataChanged', this._multiData, this.transition);
        }
      }

      _registerItem(name, item) {
        if (!this[name].includes(item)) {
          this.push(name, item);
          if (item.afterRegister) {
            item.afterRegister(this);
          }
        }
      }

      _onMultiRegister(e, d) {
        // Note(cg): only react if groupName is not set or is the same.
        if (!d || d === this.groupName) {
          // Note(cg): make sure we are not self-registering 
          // (this can be the case for elements that are registerable and also register like multi-container-g).
          const realTarget = e.composedPath()[0];
          if(realTarget !== this) {
            e.stopPropagation();
            this._registerItem('_registeredItems', realTarget);
            // Note(cg): if data is set before items are registered, they are not drawn.
            this.debounce('multi-register-register', this._callDataChanged, 40);
          }
        }
      }

      _onMultiSerieRegister(e) {
        e.stopPropagation();
        this._registerItem('series', e.composedPath()[0]);
      }


      _onRefresh(e) {
        e.stopPropagation();
        this._callDataChanged();
      }

      onResize() {
        // Note(cg): a container is responsible for notifying resize events to the registered elements.
        this.callRegistered('onResize'); 
      }

      unregister(registered) {
        this.splice('_registeredItems', this._registeredItems.indexOf(registered), 1);
        this.splice('series', this._registeredItems.indexOf(registered), 1);
        if (registered.afterUnregister) {
          registered.afterUnregister(this);
        }
        this.debounce('multi-register-unregister', this._callDataChanged, 40);
      }

      /* 
       * `shallNotify` should return true to actually render the component
       */
      shallNotify(data) {
        return !!data;
      }

      callRegistered(methodName) {
        // we replace `methodName`` with `this host` as the first argument 
        [].splice.call(arguments, 0, 1);
        const args = arguments;
        this._registeredItems
          .filter(el => {
            return el[methodName];
          })
          // Note(cg): we make sure that some registered elements (for instance `multi-selector`) are called later.
          .sort((a, b) => {
            return a.registerOrder - b.registerOrder;
          })
          .forEach(el => {
            el[methodName].apply(el, args);
          });
      }
    }

    return Register;
  });

  if (!window.MultiChart) {
    window.MultiChart = {};
  }

  /* 
   * @namespace MultiChart.mixin
   */
  window.MultiChart.mixin = window.MultiChart.mixin || {};
  /*
   * @mixinClass
   */
  window.MultiChart.mixin.MultiRegister = MultiRegister;

})();
</script>